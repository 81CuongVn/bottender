"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[61968],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=o,h=d["".concat(u,".").concat(m)]||d[m]||p[m]||a;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},40337:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>s,contentTitle:()=>u,metadata:()=>l,toc:()=>c,default:()=>d});var r=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],s={id:"the-basics-routing",title:"Routing",original_id:"the-basics-routing"},u=void 0,l={unversionedId:"the-basics-routing",id:"version-1.3.0/the-basics-routing",isDocsHomePage:!1,title:"Routing",description:"Routing is a handy design pattern to help you organize bot actions.",source:"@site/versioned_docs/version-1.3.0/the-basics-routing.md",sourceDirName:".",slug:"/the-basics-routing",permalink:"/docs/1.3.0/the-basics-routing",editUrl:"https://github.com/Yoctol/bottender/edit/master/docs/versioned_docs/version-1.3.0/the-basics-routing.md",tags:[],version:"1.3.0",lastUpdatedBy:"\u5433\u6771\u66c4 Wu, Dung-Ie",lastUpdatedAt:1636542901,formattedLastUpdatedAt:"11/10/2021",frontMatter:{id:"the-basics-routing",title:"Routing",original_id:"the-basics-routing"},sidebar:"version-1.3.0/docs",previous:{title:"Resolving Actions",permalink:"/docs/1.3.0/the-basics-actions"},next:{title:"Chain of Responsibility",permalink:"/docs/1.3.0/the-basics-chain"}},c=[{value:"Regular Expression Routes",id:"regular-expression-routes",children:[],level:2},{value:"Fallback Routes",id:"fallback-routes",children:[],level:2},{value:"Payload Routes",id:"payload-routes",children:[],level:2},{value:"Custom Routes",id:"custom-routes",children:[],level:2},{value:"Platform Specific Routes",id:"platform-specific-routes",children:[],level:2}],p={toc:c};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Routing")," is a handy design pattern to help you organize bot actions."),(0,a.kt)("p",null,"The most basic Bottender ",(0,a.kt)("inlineCode",{parentName:"p"},"Route")," is composed of a text and an action, providing a straightforward and expressive definition:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { router, text } = require('bottender/router');\n\nasync function SayHi(context) {\n  await context.sendText('Hi!');\n}\n\nasync function SayHello(context) {\n  await context.sendText('Hello!');\n}\n\nasync function App() {\n  return router([\n    text('hi', SayHi), // return SayHi when receiving hi text message\n    text('hello', SayHello), // return SayHello when receiving hello text message\n  ]);\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Router")," is consists of an array of ",(0,a.kt)("inlineCode",{parentName:"p"},"Routes"),". It returns the action of the first matched route. It is possible to have nested routers or any pattern that compatible with actions."),(0,a.kt)("p",null,"The first argument of route defines the matching rule, which could be an array of strings. The action of the route will be returned when one of the strings is matched:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function App(context) {\n  return router([\n    // // return SayHi when receiving hi or hello or hey text message\n    text(['hi', 'hello', 'hey'], SayHi),\n  ]);\n}\n")),(0,a.kt)("h2",{id:"regular-expression-routes"},"Regular Expression Routes"),(0,a.kt)("p",null,"If you are familiar with ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"},"regular expressions"),", it's a powerful way to extend your matching rules with JavaScript RegExp:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function App(context) {\n  return router([\n    // return SayHi when receiving case-insensitive hi or hello text message\n    text(/^(hi|hello)$/i, SayHi),\n  ]);\n}\n")),(0,a.kt)("p",null,"Sometimes you may want to add ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-regexp-named-groups"},"named capture groups to your JavaScript RegExps"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function App(context) {\n  return router([\n    // return Command when receiving /join, /invite, /whatever\n    text(/^\\/(?<command>\\S+)$/i, Command),\n  ]);\n}\n")),(0,a.kt)("p",null,"Then, you can access match groups result in your props:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function Command(\n  context,\n  {\n    match: {\n      groups: { command },\n    },\n  }\n) {\n  // | input | command |\n  // | --------- | ---------- |\n  // | /join | `join` |\n  // | /invite | `invite` |\n  // | /whatever | `whatever` |\n  await context.sendText(`Executing command: ${command}`);\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note:")," ",(0,a.kt)("inlineCode",{parentName:"p"},"RegExp Named Capturing Groups")," is supported by Node 10+.")),(0,a.kt)("h2",{id:"fallback-routes"},"Fallback Routes"),(0,a.kt)("p",null,"By using the ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," as the first argument, you may define a route for unhandled events, which triggers whenever no other routes match the incoming event. Meanwhile, reply to unhandled events is a chance to introduce bot features by sending a fallback message or a user's manual."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function Unknown(context) {\n  await context.sendText('Sorry. I do not understand what you say.');\n}\n\nasync function App(context) {\n  return router([\n    text(/^(hi|hello)$/i, SayHi),\n    // return Unknown when when no other route matches the incoming text message\n    text('*', Unknown),\n  ]);\n}\n")),(0,a.kt)("p",null,"Besides all unhandled text message events, you can fallback all events by ",(0,a.kt)("inlineCode",{parentName:"p"},"route('*', ...)")," instead:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { router, route, text } = require('bottender/router');\n\nasync function App(context) {\n  return router([\n    text(/^(hi|hello)$/i, SayHi),\n    // return Unknown when when no other route matches the incoming event\n    route('*', Unknown),\n  ]);\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note:")," The fallback route must be the final route in your router.")),(0,a.kt)("h2",{id:"payload-routes"},"Payload Routes"),(0,a.kt)("p",null,"Payload events typically happen when users send payload data by clicking buttons, selecting menus, or clicking keyboards. For example, you may catch ",(0,a.kt)("inlineCode",{parentName:"p"},"GET_STARTED")," payload that send by button click and respond with ",(0,a.kt)("inlineCode",{parentName:"p"},"SayHi")," action:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { router, payload } = require('bottender/router');\n\nasync function App(context) {\n  return router([\n    payload('GET_STARTED', SayHi),\n    // return Unknown when when no other route matches the incoming event\n    route('*', Unknown),\n  ]);\n}\n")),(0,a.kt)("h2",{id:"custom-routes"},"Custom Routes"),(0,a.kt)("p",null,"If you wish to use your route predicate, you may use the ",(0,a.kt)("inlineCode",{parentName:"p"},"route")," to create your route wrapper."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { router, route } = require('bottender/router');\n\nfunction sayHiTo(name, Action) {\n  return route((context) => context.event.text === `Hi ${name}`, Action);\n}\n\nasync function App(context) {\n  return router([\n    sayHiTo('Bottender', SayHi),\n    // return Unknown when when no other route matches the incoming event\n    route('*', Unknown),\n  ]);\n}\n")),(0,a.kt)("p",null,"In the above example, the custom route matches ",(0,a.kt)("inlineCode",{parentName:"p"},"Hi Bottender")," text message and resolve ",(0,a.kt)("inlineCode",{parentName:"p"},"SayHi")," action."),(0,a.kt)("h2",{id:"platform-specific-routes"},"Platform Specific Routes"),(0,a.kt)("p",null,"Bottender includes a bunch of helpers to route within your multi-platform application. To learn more about the details of those specific routes, check out their documentation:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.3.0/channel-messenger-routing"},"Messenger Routes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.3.0/channel-whatsapp-routing"},"WhatsApp Routes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.3.0/channel-line-routing"},"LINE Routes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.3.0/channel-slack-routing"},"Slack Routes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.3.0/channel-telegram-routing"},"Telegram Routes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.3.0/channel-viber-routing"},"Viber Routes"))))}d.isMDXComponent=!0}}]);