"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[97648],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(u,".").concat(m)]||d[m]||p[m]||a;return n?r.createElement(h,i(i({ref:t},l),{},{components:n})):r.createElement(h,i({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},66781:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>s,contentTitle:()=>u,metadata:()=>c,toc:()=>l,default:()=>d});var r=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],s={id:"the-basics-routing",title:"Routing",original_id:"the-basics-routing"},u=void 0,c={unversionedId:"the-basics-routing",id:"version-1.0.5/the-basics-routing",isDocsHomePage:!1,title:"Routing",description:"Routing is a handy design pattern to help you organize bot actions.",source:"@site/versioned_docs/version-1.0.5/the-basics-routing.md",sourceDirName:".",slug:"/the-basics-routing",permalink:"/docs/1.0.5/the-basics-routing",editUrl:"https://github.com/Yoctol/bottender/edit/master/docs/versioned_docs/version-1.0.5/the-basics-routing.md",tags:[],version:"1.0.5",lastUpdatedBy:"\u5433\u6771\u66c4 Wu, Dung-Ie",lastUpdatedAt:1636542901,formattedLastUpdatedAt:"11/10/2021",frontMatter:{id:"the-basics-routing",title:"Routing",original_id:"the-basics-routing"},sidebar:"version-1.0.5/docs",previous:{title:"Resolving Actions",permalink:"/docs/1.0.5/the-basics-actions"},next:{title:"Chain of Responsibility",permalink:"/docs/1.0.5/the-basics-chain"}},l=[{value:"Regular Expression Routes",id:"regular-expression-routes",children:[],level:2},{value:"Fallback Routes",id:"fallback-routes",children:[],level:2}],p={toc:l};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Routing is a handy design pattern to help you organize bot actions.",(0,a.kt)("br",{parentName:"p"}),"\n","The most basic Bottender route is composed by a text and an action, providing a very simple and expressive method of route definition:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { router, text } = require('bottender/router');\n\nasync function SayHi(context) {\n  await context.sendText('Hi!');\n}\n\nasync function SayHello(context) {\n  await context.sendText('Hello!');\n}\n\nasync function App() {\n  return router([\n    text('hi', SayHi), // return SayHi when receiving hi text message\n    text('hello', SayHello), // return SayHello when receiving hello text message\n  ]);\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"router")," is consist of an array of routes. It returns the action of the first matched route. It's possible to have nested routers or any pattern that compatible with actions."),(0,a.kt)("p",null,"The first argument of route defines the matching rule, which could be an array of strings. The action of the route will be returned when one of the strings is matched:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function App(context) {\n  return router([\n    // // return SayHi when receiving hi or hello or hey text message\n    text(['hi', 'hello', 'hey'], SayHi),\n  ]);\n}\n")),(0,a.kt)("h2",{id:"regular-expression-routes"},"Regular Expression Routes"),(0,a.kt)("p",null,"If you are familiar with ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"},"regular expressions"),", it's a powerful way to extend your matching rules with JavaScript RegExp:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function App(context) {\n  return router([\n    // return SayHi when receiving case-insensitive hi or hello text message\n    text(/^(hi|hello)$/i, SayHi),\n  ]);\n}\n")),(0,a.kt)("p",null,"Sometimes you may want to add ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-regexp-named-groups"},"named capture groups to your JavaScript RegExps"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function App(context) {\n  return router([\n    // return Command when receiving /join, /invite, /whatever\n    text(/^\\/(?<command>\\S+)$/i, Command),\n  ]);\n}\n")),(0,a.kt)("p",null,"Then, you can access match groups result in your props:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function Command(\n  context,\n  {\n    match: {\n      groups: { command },\n    },\n  }\n) {\n  // | input     | command    |\n  // | --------- | ---------- |\n  // | /join     | `join`     |\n  // | /invite   | `invite`   |\n  // | /whatever | `whatever` |\n  await context.sendText(`Executing command: ${command}`);\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note:")," ",(0,a.kt)("inlineCode",{parentName:"p"},"RegExp Named Capturing Groups")," is supported from Node 10.")),(0,a.kt)("h2",{id:"fallback-routes"},"Fallback Routes"),(0,a.kt)("p",null,"By using the ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," as the first argument, you may define a route for unhandled events, which will be triggered whenever no other routes match the incoming event. Meanwhile, reply of unhandled events is a chance to introudce bot features by sending a fallback message or a user's manual."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"async function Unknown(context) {\n  await context.sendText('Sorry. I do not understand what you say.');\n}\n\nasync function App(context) {\n  return router([\n    text(/^(hi|hello)$/i, SayHi),\n    // return Unknown when when no other route matches the incoming text message\n    text('*', Unknown),\n  ]);\n}\n")),(0,a.kt)("p",null,"Besides all unhandled text message events, you can fallback all events by ",(0,a.kt)("inlineCode",{parentName:"p"},"route('*', ...)")," instead:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { router, route, text } = require('bottender/router');\n\nasync function App(context) {\n  return router([\n    text(/^(hi|hello)$/i, SayHi),\n    // return Unknown when when no other route matches the incoming event\n    route('*', Unknown),\n  ]);\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note:")," The fallback route should always be the last route registered in your router.")))}d.isMDXComponent=!0}}]);